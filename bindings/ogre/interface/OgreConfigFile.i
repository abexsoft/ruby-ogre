%{

#include <OgreConfigFile.h>

%}

%ignore Ogre::ConfigFile::load(const String&, const String&);


/* 
 * A record of a big battle.
 * 
//%ignore *::getNext();
//%ignore Ogre::MapIteratorWrapper<Ogre::ConfigFile::SettingsBySection, typename Ogre::ConfigFile::SettingsBySection::iterator >::getNext();
%rename(getNextOld) Ogre::MapIteratorWrapper<Ogre::ConfigFile::SettingsBySection, typename Ogre::ConfigFile::SettingsBySection::iterator >::getNext();

//%feature("valuewrapper") Ogre::ConfigFile::SectionIterator;
//class Ogre::ConfigFile::SectionIterator;
//%feature("valuewrapper") Ogre::ConfigFile::SettingsIterator;
//class Ogre::ConfigFile::SettingsIterator;


%template(StdPairTemplate) std::pair<std::string const,std::string>;
//%template(Generanl) Ogre::CategorisedAllocPolicy<Ogre::MEMCATEGORY_GENERAL>;
//%template() Ogre::CategorisedAllocPolicy<Ogre::MEMCATEGORY_GENERAL>;
%template(StlAllocatorB) Ogre::STLAllocatorBase< std::pair< std::string const,std::string > >;

// avoid to collide the STLAllocator::allocate method with the allocate function of STLAllocator generated by swig.
%rename(allocate2) allocate( size_type count, typename std::allocator<void>::const_pointer ptr = 0 );
%template(StlAllocatorA) Ogre::STLAllocator<std::pair< std::string const,std::string >, Ogre::CategorisedAllocPolicy< Ogre::MEMCATEGORY_GENERAL > >;

// typedef multimap< String,String >::type SettingsMultiMap
%template(StringPair) std::pair<std::string, std::string >;
%template(SettingsMapTemplate) std::map< Ogre::String, Ogre::String >;
%template(SettingsMultiMapTemplate) std::multimap< Ogre::String, Ogre::String >;

// typedef MapIterator< SettingsMultiMap >
%template(MapIteratorSettingsTemplate) Ogre::MapIterator<Ogre::ConfigFile::SettingsMultiMap>;


// typedef map< String, SettingsMultiMap * >::type SettingsBySection
%template(StringMultimap) std::multimap<std::string, std::string, std::less<std::string>, Ogre::STLAllocator<std::pair<const std::string, std::string >, Ogre::CategorisedAllocPolicy<(Ogre::MemoryCategory)0u> > > ;
%template(SettingsBySectionTemplate) std::map<Ogre::String, Ogre::ConfigFile::SettingsMultiMap* >;


// typedef MapIterator< SettingsBySection > SectionIterator
%template(IteratorWrapperTemplate) Ogre::IteratorWrapper<Ogre::ConfigFile::SettingsBySection, Ogre::ConfigFile::SettingsBySection::iterator, typename Ogre::ConfigFile::SettingsBySection::mapped_type >;
%template(MapIteratorWrapperTemplate) Ogre::MapIteratorWrapper<Ogre::ConfigFile::SettingsBySection, typename Ogre::ConfigFile::SettingsBySection::iterator >;
%template(MapIteratorTemplate) Ogre::MapIterator<Ogre::ConfigFile::SettingsBySection>;

%extend Ogre::MapIteratorWrapper<Ogre::ConfigFile::SettingsBySection, typename Ogre::ConfigFile::SettingsBySection::iterator > {
//	std::multimap< Ogre::String, Ogre::String >* getNext2() { 
	Ogre::ConfigFile::SettingsMultiMap* getNext2() {
		Ogre::String sec, type, arch;

		Ogre::ConfigFile::SettingsMultiMap* settings = self->getNext(); 
		return settings; 
	}
}
*/

%extend Ogre::ConfigFile {
	void each_Settings() {
		Ogre::ConfigFile::SectionIterator seci = self->getSectionIterator();
		Ogre::String secName, typeName, archName;
		while (seci.hasMoreElements()) {
			secName = seci.peekNextKey();

			Ogre::ConfigFile::SettingsMultiMap *settings = seci.getNext();
			Ogre::ConfigFile::SettingsMultiMap::iterator i;
			for (i = settings->begin(); i != settings->end(); ++i) {
				typeName = i->first;
				archName = i->second;
				rb_yield_values(3,
						rb_str_new2(secName.c_str()),
						rb_str_new2(typeName.c_str()),
						rb_str_new2(archName.c_str()));
			}
		}
	}
 }


%include OgreConfigFile.h

%{

%}
